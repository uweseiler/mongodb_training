// lab2.js

var db = db.getSisterDB("blog");

initArticles = function () {

    var t = db.articles;
    
	t.insert({ _id : 2, name : "Read Operations", text : "Read operations include all operations that return a cursor in response to application request data (i.e. queries,) and also include a number of aggregation operations that do not return a cursor but have similar properties as queries. These commands include aggregate, count, and distinct.", author : "Howard" });
	t.insert({ _id : 3, name : "Queries in MongoDB", text : "In the mongo shell, the find() and findOne() methods perform read operations. The find() method has the following syntax:", author : "Amy" });
	t.insert({ _id : 4, name : "Subdocuments", text : "When the field holds an embedded document (i.e. subdocument), you can either specify the entire subdocument as the value of a field, or “reach into” the subdocument using dot notation, to specify values for individual fields in the subdocument:", author : "Raj" });
	t.insert({ _id : 5, name : "Arrays", text : "When the field holds an array, you can query for values in the array, and if the array holds sub-documents, you query for specific fields within the sub-documents using dot notation:", author : "Penny" });
	t.insert({ _id : 6, name : "Result projections", text : "The projection specification limits the fields to return for all matching documents. Restricting the fields to return can minimize network transit costs and the costs of deserializing documents in the application layer.", author : "Sheldon" });
	t.insert({ _id : 7, name : "Indexes", text : "Indexes improve the efficiency of read operations by reducing the amount of data that query operations need to process and thereby simplifying the work associated with fulfilling queries within MongoDB. The indexes themselves are a special data structure that MongoDB maintains when inserting or modifying documents, and any given index can: support and optimize specific queries, sort operations, and allow for more efficient storage utilization. ", author : "Leonard" });
	t.insert({ _id : 8, name : "Measuring index use", text : "The explain() cursor method allows you to inspect the operation of the query system, and is useful for analyzing the efficiency of queries, and for determining how the query uses the index. ", author : "Raj" });
	t.insert({ _id : 9, name : "Queries optimization", text : "The MongoDB query optimizer processes queries and chooses the most efficient query plan for a query given the available indexes. The query system then uses this query plan each time the query runs. The query optimizer occasionally reevaluates query plans as the content of the collection changes to ensure optimal query plans.", author : "Howard" });
	t.insert({ _id : 10, name : "Cursors", text : "The find() method returns a cursor to the results; however, in the mongo shell, if the returned cursor is not assigned to a variable, then the cursor is automatically iterated up to 20 times [2] to print up to the first 20 documents that match the query, as in the following example:", author : "Amy" });
	t.insert({ _id : 11, name : "Aggregation", text : "MongoDB can perform some basic data aggregation operations on results before returning data to the application. These operations are not queries; they use database commands rather than queries, and they do not return a cursor. However, they still require MongoDB to read data.Running aggregation operations on the database side can be more efficient than running them in the application layer and can reduce the amount of data MongoDB needs to send to the application. These aggregation operations include basic grouping, counting, and even processing data using a map reduce framework. Additionally, in 2.2 MongoDB provides a complete aggregation framework for more rich aggregation operations.", author : "Sheldon" });
	t.insert({ _id : 12, name : "Read operations from Sharded Clusters", text : "Sharded clusters allow you to partition a data set among a cluster of mongod in a way that is nearly transparent to the application. See the Sharding section of this manual for additional information about these deployments. For a sharded cluster, you issue all operations to one of the mongos instances associated with the cluster. mongos instances route operations to the mongod in the cluster and behave like mongod instances to the application. Read operations to a sharded collection in a sharded cluster are largely the same as operations to a replica set or standalone instances. See the section on Read Operations in Sharded Clusters for more information.", author : "Penny" });
	t.insert({ _id : 13, name : "Read operations from Replica Sets", text : "Replica sets use read preferences to determine where and how to route read operations to members of the replica set. By default, MongoDB always reads data from a replica set’s primary. You can modify that behavior by changing the read preference mode.", author : "Ray" });
	t.insert({ _id : 14, name : "Internal operation of Write Concern", text : "To provide write concern, drivers issue the getLastError command after a write operation and receive a document with information about the last operation. This document’s err field contains either:", author : "Sheldon" });
	t.insert({ _id : 15, name : "Bulk Inserts", text : "In some situations you may need to insert or ingest a large amount of data into a MongoDB database. These bulk inserts have some special considerations that are different from other write operations. The insert() method, when passed an array of documents, will perform a bulk insert, and inserts each document atomically. Drivers provide their own interface for this kind of operation.", author : "Leonard" });
	t.insert({ _id : 16, name : "Isolation", text : "When a single write operation modifies multiple documents, the operation as a whole is not atomic, and other operations may interleave. The modification of a single document, or record, is always atomic, even if the write operation modifies multiple sub-document within the single record.", author : "Bernadette" });

    printjson( db.getLastErrorObj() );
    print( "ok!");
}

restoreArticles = function () {

    var t = db.articles;

    print("db.articles will drop and reload...");
    t.drop();
    
	t.insert({ _id : 1, name : "Welcome", text : "Welcome to the MongoDB Blog!", author : "Sheldon"});
	t.insert({ _id : 2, name : "Read Operations", text : "Read operations include all operations that return a cursor in response to application request data (i.e. queries,) and also include a number of aggregation operations that do not return a cursor but have similar properties as queries. These commands include aggregate, count, and distinct.", author : "Howard" });
	t.insert({ _id : 3, name : "Queries in MongoDB", text : "In the mongo shell, the find() and findOne() methods perform read operations. The find() method has the following syntax:", author : "Amy" });
	t.insert({ _id : 4, name : "Subdocuments", text : "When the field holds an embedded document (i.e. subdocument), you can either specify the entire subdocument as the value of a field, or “reach into” the subdocument using dot notation, to specify values for individual fields in the subdocument:", author : "Raj" });
	t.insert({ _id : 5, name : "Arrays", text : "When the field holds an array, you can query for values in the array, and if the array holds sub-documents, you query for specific fields within the sub-documents using dot notation:", author : "Penny" });
	t.insert({ _id : 6, name : "Result projections", text : "The projection specification limits the fields to return for all matching documents. Restricting the fields to return can minimize network transit costs and the costs of deserializing documents in the application layer.", author : "Sheldon" });
	t.insert({ _id : 7, name : "Indexes", text : "Indexes improve the efficiency of read operations by reducing the amount of data that query operations need to process and thereby simplifying the work associated with fulfilling queries within MongoDB. The indexes themselves are a special data structure that MongoDB maintains when inserting or modifying documents, and any given index can: support and optimize specific queries, sort operations, and allow for more efficient storage utilization. ", author : "Leonard" });
	t.insert({ _id : 8, name : "Measuring index use", text : "The explain() cursor method allows you to inspect the operation of the query system, and is useful for analyzing the efficiency of queries, and for determining how the query uses the index. ", author : "Raj" });
	t.insert({ _id : 9, name : "Queries optimization", text : "The MongoDB query optimizer processes queries and chooses the most efficient query plan for a query given the available indexes. The query system then uses this query plan each time the query runs. The query optimizer occasionally reevaluates query plans as the content of the collection changes to ensure optimal query plans.", author : "Howard" });
	t.insert({ _id : 10, name : "Cursors", text : "The find() method returns a cursor to the results; however, in the mongo shell, if the returned cursor is not assigned to a variable, then the cursor is automatically iterated up to 20 times [2] to print up to the first 20 documents that match the query, as in the following example:", author : "Amy" });
	t.insert({ _id : 11, name : "Aggregation", text : "MongoDB can perform some basic data aggregation operations on results before returning data to the application. These operations are not queries; they use database commands rather than queries, and they do not return a cursor. However, they still require MongoDB to read data.Running aggregation operations on the database side can be more efficient than running them in the application layer and can reduce the amount of data MongoDB needs to send to the application. These aggregation operations include basic grouping, counting, and even processing data using a map reduce framework. Additionally, in 2.2 MongoDB provides a complete aggregation framework for more rich aggregation operations.", author : "Sheldon" });
	t.insert({ _id : 12, name : "Read operations from Sharded Clusters", text : "Sharded clusters allow you to partition a data set among a cluster of mongod in a way that is nearly transparent to the application. See the Sharding section of this manual for additional information about these deployments. For a sharded cluster, you issue all operations to one of the mongos instances associated with the cluster. mongos instances route operations to the mongod in the cluster and behave like mongod instances to the application. Read operations to a sharded collection in a sharded cluster are largely the same as operations to a replica set or standalone instances. See the section on Read Operations in Sharded Clusters for more information.", author : "Penny" });
	t.insert({ _id : 13, name : "Read operations from Replica Sets", text : "Replica sets use read preferences to determine where and how to route read operations to members of the replica set. By default, MongoDB always reads data from a replica set’s primary. You can modify that behavior by changing the read preference mode.", author : "Ray" });
	t.insert({ _id : 14, name : "Internal operation of Write Concern", text : "To provide write concern, drivers issue the getLastError command after a write operation and receive a document with information about the last operation. This document’s err field contains either:", author : "Sheldon" });
	t.insert({ _id : 15, name : "Bulk Inserts", text : "In some situations you may need to insert or ingest a large amount of data into a MongoDB database. These bulk inserts have some special considerations that are different from other write operations. The insert() method, when passed an array of documents, will perform a bulk insert, and inserts each document atomically. Drivers provide their own interface for this kind of operation.", author : "Leonard" });
	t.insert({ _id : 16, name : "Isolation", text : "When a single write operation modifies multiple documents, the operation as a whole is not atomic, and other operations may interleave. The modification of a single document, or record, is always atomic, even if the write operation modifies multiple sub-document within the single record.", author : "Bernadette" });

    printjson( db.getLastErrorObj() );
    print( "Restore ok!");
}